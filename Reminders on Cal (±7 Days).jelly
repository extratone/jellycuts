import Shortcuts
#Color: grape, #Icon: checklist

/*
â„¹ï¸ INTRODUCTION & FEATURES

Welcome! This Shortcut creates a âœ¨two-way syncâœ¨ between your Reminders and Cal Events up to seven days from now.

When it runs:
â€¢ Cal Events are created based on newly-added Reminders
â€¢ Reminders are created based on newly-added Events
â€¢ These items are *two-way* synced - changing the time/date of any synced item will update the item on BOTH apps
    â€¢ With some exceptions - check the â€˜time-sensitive eventsâ€™ notes below
â€¢ All-day events will sync as date-only Reminders (and vice versa)
â€¢ You can block new Reminders from being synced by adding â€œ#nosyncâ€ to its tags
*/
/*
â„¹ï¸ WHAT TO LOOK OUT FOR / HOW TAGS WORK

Each synced Event will get an odd line of text in its Notes
â€¢ This is the Reminder ID. Itâ€™s used to directly link the Event with its Reminder.
â€¢ Itâ€™s important to not alter that particular line of text
â€¢ Butonâ€™t worry, it wonâ€™t disturb any existing notes, and you can add/edit notes around it

Each synced Reminder will have the tag #oncal
â€¢ This is to show you which Reminders are synced or not

â€˜Time-sensitiveâ€™ Events only have a one-way sync
â€¢ Reminders for these Events get a #Event tag
â€¢ Edits to the Event will affect its Reminder, but the Reminder will snap back into place if edited
â€¢ This is to avoid any mistakes you make within Reminders from affecting the Eventâ€™s details
â€¢ By default, Events considered â€˜time-sensitiveâ€™ are ones that are shared events, have a location, or have the keyword â€œappointmentâ€ or callâ€
â€¢ You can edit these settings (or remove them entirely) in the workflow at the very bottom of this Shortcut
*/
/*
ðŸš¨ðŸš¨ðŸš¨ SET UP: Which Calendar do you want to sync?

â€¢ Make sure the Calendar is already set up in your Calendar app
â€¢ Set the text box below to the EXACT spelling and capitalization of the Calendar
*/
text(text: "Reminders") >> Cal Text
var CalName = Cal Text
/*
ðŸš¨ðŸš¨ðŸš¨ SET UP: Which Reminder List do you want to sync?

â€¢ Make sure the list is already set up in your Reminders app
â€¢ Set the text box below to the EXACT spellung and calitalization of the listâ€™s title
VVVVVV
*/
text(text: "Reminders") >> List Text
var ListName = List Text
list(items: (
    Appointment,
    appointment,
    Meet,
    meet,
    Call,
    call
)) >> list
var KeywordListforTime-SensitiveEvents = List
adjustDate(operation: Get Start of Week, date: "${CurrentDate}") >> Start of Week
adjustDate(duration: , date: "${CurrentDate}") >> 7 Days From Now
filterCalendar() >> filterCalendar
repeatEach(Calendar Events) {
	if(Repeat Item .contains "â—¦â—¦") {
/*
If the Event has the cookieâ€™s â€œâ—¦â—¦â€, itâ€™ll have a Creation Date to find its Reminder.

This is where â€œâ—¦â—¦â€ comes in as a (hopefully unique) custom separator.

If we use the Split Action to break up the cookie, we can isolate the Date value which will be found in Index 2.
*/
		splitText(text: Repeat Item, separator: Custom, customSeparator: " â—¦â—¦ ") >> splitText
		getItemFromList(list: Split Text, type: Item At Index, index: "2") >> getItemFromList
var EventReminderCreationDate = Item from List
// Now letâ€™s find all of the existing Remindersâ€¦
		filterReminders() >> Existing Reminder
		if(Existing Reminder != nil) {
			if(Existing Reminder ==) {
// If the Reminder/task is completed ahead of time, this sets the Event to free up your schedule.
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
				if(Repeat Item >) {
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
				}
			} else {
/*
This is the key to the two-way sync.

If we find a live #oncal Reminder and its Event, they get brought here.

Basically, whichever item was *last modified* is the authority on the Start/Due Date for the synced pair.

When time between is calculated, Events â€˜winâ€™ with a positive value, Reminders â€˜winâ€™ with a negative.

All-day Events have date-only Reminders. Theyâ€™re both very format-sensitive, but too common not to include.
*/
				getTimeBetween(first: "${Repeat Item.get(Last Modified Date)}", second: "${Existing Reminder.get(Last Modified Date)}", interval: Seconds) >> getTimeBetween
				if(Time Between Dates false 0) {
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
					if(Repeat Item ==) {
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
					}
				} else {
//Unable to get shortcuts action is.workflow.actions.setters.reminders
					if(Repeat Item ==) {
//Unable to get shortcuts action is.workflow.actions.setters.reminders
					}
				}
			}
		} else {
/*
If a Reminder for a synced Event gets â€œlostâ€, this section makes a fresh synced Reminder.
â€¢ We have to surgically replace the Creation Date
*/
			wait()
//Unable to get shortcuts action is.workflow.actions.addnewreminder
			text(text: "${Repeat Item.as().get(Notes)}") >> Original Notes
			replaceText(input: "${Original Notes}", find: "â—¦â—¦ ${Event Reminder Creation Date} â—¦â—¦", replace: "â—¦â—¦ ${New Reminder.get(Creation Date)} â—¦â—¦") >> replaceText
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
		}
	} else {
/*
Hereâ€™s where the Shortcut creates new Reminders and adds the â€˜cookieâ€™ to the Event.
â€¢ Warning: again, avoid editing the cookie, especially the â€œâ—¦â—¦â€
â€¢ The Wait action below causes lag but is ESSENTIAL â€” it ensures that each Reminder has a unique Creation Date
*/
		wait()
		if(Repeat Item ==) {
//Unable to get shortcuts action is.workflow.actions.addnewreminder
var CD71CD7D-FDE6-462B-86FB-C224C9ABF07C = """ï¿¼


â€”â€”â€”
(Reminder ID â€¢ Keep for sync â—¦â—¦ ï¿¼ â—¦â—¦ )"""
text("${CD71CD7D-FDE6-462B-86FB-C224C9ABF07C}")
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
		} else {
//Unable to get shortcuts action is.workflow.actions.addnewreminder
var DA32DE9C-EDF6-46B0-94D4-76040F5A4981 = """ï¿¼


â€”â€”â€”
(Reminder ID â€¢ Keep for sync â—¦â—¦ ï¿¼ â—¦â—¦ )"""
text("${DA32DE9C-EDF6-46B0-94D4-76040F5A4981}")
//Unable to get shortcuts action is.workflow.actions.setters.calendarevents
		}
	} >> IFResult
} >> RepeatResult
/*
Find reminders that have a due date to be put on the calendar
- excludes reminders that are already tagged #onCal or any other excluding tags
vvvvv
*/
filterReminders() >> filterReminders
repeatEach(Reminders) {
	filterCalendar() >> filterCalendar 1
	if(Calendar Events == nil) {
		removeReminders(reminders: Repeat Item) >> removeReminders
	}
} >> RepeatResult 1
filterReminders() >> New Unsynced Reminders
repeatEach(New Unsynced Reminders) { >> RepeatResult 2
/*
â€¢ If the start time is 00:00, itâ€™s most likely a Reminder with a date but no time.
â€¢ If the Reminder starts at 00:00, the output will be an all-day Event.
vvvvv
*/
	if(Repeat Item == "00:00") {
//Unable to get shortcuts action is.workflow.actions.addnewevent
//Unable to get shortcuts action is.workflow.actions.setters.reminders
/*
Otherwise, the output is a new Calendar Event at the Reminderâ€™s Due Date.

The default length is 15 minutes, but you can customize it. Also, you can still safely edit a synced Eventâ€™s duration.
vvvvv
*/
	} else {
		adjustDate(operation: Add, duration: , date: "${Repeat Item.get(Due Date)}") >> adjustDate
//Unable to get shortcuts action is.workflow.actions.addnewevent
//Unable to get shortcuts action is.workflow.actions.setters.reminders
	} >> IFResult 1
} >> RepeatResult 3
/*
ðŸ’¡ #Event: Preserving Time-Sensitive Events ðŸ’¡

â€¢ Problem: Meetings, calls, etc. are time-sensitive events. What if we get mixed up and move a Reminder to the wrong time? What if thereâ€™s a bug and a shared Calendar Event gets scrambled/deleted?

To avoid errors, this Shortcut doesnâ€™t edit any Events with these properties:
â€¢ A location
â€¢ One or more attendees
â€¢ Event-related keywords (e.g. â€œappointmentâ€, â€œcallâ€)

Instead, the script does a ONE-WAY sync. Edits to a Reminder wonâ€™t sync with the Event, and will mainly just snap back to the Eventâ€™s details.

Instead of adding a line of code to the eventâ€™s Notes, Reminders that have a #Event tag will simply line up with an Event matching their name.

While itâ€™s been tested, this miiiight cause some mixups with recurring Events, as we canâ€™t rely on a unique timestamp.

Feel free to delete this section entirely, make adjustments, or customize the time-sensitive keyword list directly below
vvvvvv
*/
filterCalendar() >> Events with Time-Sensitive Keywords
filterCalendar() >> Events with Invitees
filterCalendar() >> Events with Locations
list(items: (
        {
        WFItemType = 0;
        WFValue =         {
            Value =             {
                attachmentsByRange =                 {
                    "{0, 1}" =                     {
                        OutputName = "Events with Invitees";
                        OutputUUID = "33D7C1C7-BF00-4B0A-B12E-D9EC43BDB5A6";
                        Type = ActionOutput;
                    };
                };
                string = "\Ufffc";
            };
            WFSerializationType = WFTextTokenString;
        };
    },
        {
        WFItemType = 0;
        WFValue =         {
            Value =             {
                attachmentsByRange =                 {
                    "{0, 1}" =                     {
                        OutputName = "Events with Locations";
                        OutputUUID = "E41A38E4-42F4-423B-9A25-16A64E66F515";
                        Type = ActionOutput;
                    };
                };
                string = "\Ufffc";
            };
            WFSerializationType = WFTextTokenString;
        };
    },
        {
        WFItemType = 0;
        WFValue =         {
            Value =             {
                attachmentsByRange =                 {
                    "{0, 1}" =                     {
                        OutputName = "Events with Time-Sensitive Keywords";
                        OutputUUID = "6F385A56-2981-4162-A046-DAC77B0689B0";
                        Type = ActionOutput;
                    };
                };
                string = "\Ufffc";
            };
            WFSerializationType = WFTextTokenString;
        };
    }
)) >> list 1
repeatEach(List) {
	filterReminders() >> filterReminders 1
	if(Reminders != nil) {
		if(Reminders !=) {
//Unable to get shortcuts action is.workflow.actions.setters.reminders
		} else {
		}
	} else {
//Unable to get shortcuts action is.workflow.actions.addnewreminder
	} >> IFResult 2
}
